defmodule Tsk do
  import UUID

  defstruct name: nil, code: Tsk.Noop

  # needed to create new nodes with different default names
  def new(fieldUpdates), do: Map.merge(  %{%Node{} | name: String.to_atom(UUID.uuid4)}, Enum.into(fieldUpdates, %{}))

  # execute node operations on a graph
  def doAdd(graph, node), do: :digraph.add_vertex graph, node.name, node
  def doDel(graph, node), do: :digraph.del_vertex graph, node.name
  def doUpdate(graph, node, changes) do
    # changes is a keyword list
    new_node = 
      Enum.reduce changes, node, fn({ch_key, ch_value}, acc) -> 
        Map.put(acc, ch_key, ch_value)
      end
    Node.add graph, new_node
  end

  # create messages that can be processed by Tskr.Store
  def add(node),             do: %{op: &Node.doAdd/2, args: [node]}
  def del(node),             do: %{op: &Node.doDel/2, args: [node]}
  def update(node, changes), do: %{op: &Node.doUpdate/3, args: [node, changes]}

  # def add(node), do: %{op: :node_add, node: node}
  # def del(node), do: %{op: :node_del, node: node}
  # def update(node, args), do: %{op: :node_update, node: node, args: args}

end


defmodule Edge do
  import UUID

  def defaultFilter(x), do: true

  defstruct name: nil, source: nil, target: nil, value: nil, valid: false, filter: &Edge.defaultFilter/1

  def new(fieldUpdates), do: Map.merge( %{%Edge{} | name: String.to_atom(UUID.uuid4)}, Enum.into(fieldUpdates, %{}))

  def doAdd(graph, edge), do: :digraph.add_edge graph, edge.name, edge.source, edge.target, edge 
  def doDel(graph, edge), do: :digraph.del_edge graph, edge.name 
  def doUpdate(graph, edge, changes) do
    # changes is a keyword list
    new_edge = 
      Enum.reduce changes, edge, fn
        ({:value, ch_value}, acc) -> acc |> Map.put(:value, ch_value) |> Map.put(:valid, true)
        ({ch_key, ch_value}, acc) -> acc |> Map.put(ch_key, ch_value)
      end
    Edge.add graph, new_edge
  end

  def add(edge),              do: %{op: &Edge.doAdd/2, args: [edge]}
  def del(edge),              do: %{op: &Edge.doDel/2, args: [edge]}
  def update(edge, changes),  do: %{op: &Edge.doUpdate/3, args: [edge, changes]}
  def updates(edges, changes) do
    for e <- edges, do: Edge.update e, changes
  end


  # def add(edge), do: %{op: :edge_add, edge: edge}
  # def del(edge), do: %{op: :edge_del, edge: edge}
  # def update(edge, args), do: %{op: :edge_update, edge: edge, args: args}

end
